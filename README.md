### 동시성 문제 해결 사례

#### 1. **문제 상황**
동시성 문제는 여러 요청이 동시에 같은 자원을 접근할 때 발생할 수 있는 문제입니다. `hhplus-tdd-nest` 프로젝트에서는 포인트 충전 및 사용과 같은 작업이 동시에 요청될 때 데이터 불일치 또는 경합 조건(race condition)이 발생할 수 있었습니다. 이러한 상황에서는 서로 다른 트랜잭션이 같은 데이터를 동시에 읽고 쓰려 할 때 문제가 발생할 수 있습니다.

#### 2. **해결 방법**
프로젝트에서는 `MutexInterceptor`를 도입하여 **동시성 제어**를 구현했습니다. 이 Interceptor는 각 사용자의 요청을 순차적으로 처리하도록 설계되었습니다. 이를 통해 같은 사용자가 동시에 포인트 충전이나 사용을 요청할 때 발생할 수 있는 충돌을 방지합니다.

- **MutexInterceptor**: 요청이 들어올 때마다 하나의 요청만 처리하도록 잠금(Mutex)을 적용하여, 중복된 요청이 순차적으로 처리되게 하였습니다. 이로 인해 한 요청이 완료되기 전에는 다른 요청이 처리되지 않도록 보장하였습니다.

#### 3. **구현 과정**
- **요청 큐 처리**: 포인트 충전 및 사용 기능에서, 각 요청이 동시에 들어오더라도 특정 사용자에 대해 먼저 들어온 요청이 처리된 후에 다음 요청이 처리되도록 하였습니다. 즉, **동시적인 요청을 순차적으로 실행**할 수 있게 설계되었습니다.
  
- **테스트 코드 작성**: 동시성 문제 해결의 정확성을 검증하기 위해 통합 테스트를 작성하였습니다. 여러 개의 충전 및 사용 요청을 동시에 보내는 시나리오에서 요청들이 순차적으로 처리되고, 그 결과가 일관되게 반영되는지를 테스트했습니다.

  예를 들어, 세 개의 충전 요청이 동시에 들어올 때:
  ```typescript
  const promise1 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 100 }).expect(200);
  const promise2 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 200 }).expect(200);
  const promise3 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 300 }).expect(200);
  ```
  각 요청이 순차적으로 처리되어 포인트가 적절히 반영되는지 확인하였습니다.

#### 4. **결과**
이 해결 방안을 통해 동시성 문제로 인한 데이터 불일치 현상을 방지할 수 있었습니다. MutexInterceptor가 동시 요청을 안전하게 처리하며, 각 요청이 올바르게 순차적으로 실행되었음을 통합 테스트를 통해 검증하였습니다.

---

이 README는 동시성 문제 해결을 위한 구체적인 사례를 제시하며, `MutexInterceptor`를 활용하여 데이터 경합 문제를 어떻게 해결했는지 설명합니다.
