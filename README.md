
# 🫨 문제상황
동시성 문제는 여러 요청이 동시에 같은 자원을 접근할 때 발생할 수 있는 문제입니다. `hhplus-tdd-nest` 프로젝트에서는 포인트 충전 및 사용과 같은 작업이 동시에 요청될 때 데이터 불일치 또는 경합 조건(race condition)이 발생할 수 있었습니다. 이러한 동시성 문제를 큐로 해결한 프로젝트 입니다.


# 💥Troubleshooting💥

## **1. Mutex → 큐 개선**

동시성 문제가 발생할 수 있는 API에 대해 `MutexInterceptor`를 적용하여 각 요청에 대해 뮤텍스(Mutex)로 락을 설정함으로써 순차적으로 요청을 처리하도록 구현하였습니다.


- **문제 상황 1: 느린 응답 속도**
    - 특정 API에 동시성 제어를 적용하자 응답 속도가 급격히 느려지는 문제가 발생했습니다. 이는 Mutex를 사용하여 들어오는 모든 요청에 대해 순차적으로 처리했기 때문입니다. 동시 다발적인 요청에 대해 모든 요청을 직렬화하여 처리하는 방식은 API 성능에 심각한 영향을 미쳤습니다. 즉, 동시성 문제를 해결하려다 전체적인 성능 저하를 초래하게 된 것입니다.


-  **문제 상황 2: 인터셉터에서의 성능 저하**

    - NestJS의 `Interceptor` 영역에서의 순차 관리로 인해 심각한 성능 저하가 발생했습니다. 인터셉터는 모든 요청을 가로채고, 해당 요청을 처리하기 전에 선행 작업을 수행하는 구조입니다. 하지만 동시성 문제를 막기 위해 요청마다 락을 거는 방식은 병렬 처리가 불가능해지며, 응답 속도가 늦어지고 전체 시스템 성능에 악영향을 미치게 됩니다.

  - **해결방안: 큐 구조 개선**

     - 동시성 문제가 발생할 수 있는 상황에서 모든 요청에 대해 일괄적으로 Mutex 락을 거는 방식이 성능을 저하시키는 원인이 되었습니다. 이에 따라 조건문을 적용하여, **동일한 자원에 접근하려는 경우에만** 해당 유저의 요청을 대기열에 추가하도록 개선하였습니다. 이로 인해, 모든 요청에 락을 걸지 않고, 필요한 상황에서만 대기열을 만들 수 있게 되었습니다.


## 2. 자바스크립트 배열의 시간 복잡도

대기열을 관리하기 위해 `Map` 자료구조를 사용하였으며, **Map의 키로 유저의 ID**를 설정하고, **Value로는 해당 유저의 요청 대기열**을 넣었습니다. 이 구조를 통해 각 유저의 대기열을 별도로 관리할 수 있게 되었으며, 특정 자원에 대해 동시에 접근할 경우 유저별로 대기열을 생성하여 동시성 문제를 해결할 수 있었습니다.

-  **문제 상황 1:** 자바스크립트 배열의 특성

    - 자바스크립트에서 배열은 동적 배열처럼 보이지만, 실제로는 **객체**와 유사하게 동작합니다. 배열의 요소들은 숫자를 키로 가지는 객체로 구현되어 있습니다. 이 때문에 배열의 첫 번째 요소를 꺼내는 작업(`shift()`)은 **O(n)**의 시간 복잡도를 가집니다. 배열의 맨 앞 요소를 제거하면 그 뒤에 있는 모든 요소들의 인덱스를 한 칸씩 앞으로 이동시키는 작업이 필요하기 때문입니다. **이러한 특성 때문에 대기열에서 맨 앞에 있는 요소를 제거하는 연산을 반복적으로 수행할 경우, 성능 저하가 발생할 수 있습니다. 특히 대기열이 커질수록 첫 번째 요소를 제거하는 연산의 비용이 증가하게 됩니다.**

- 해결방안: **Map과 LinkedList의 결합**

    - 기존의 `Map` 자료구조를 유지하면서, **Map의 Value**로 LinkedList를 사용하였습니다. 즉, 유저의 ID를 키로, 해당 유저의 요청 대기열을 LinkedList로 관리함으로써, 대기열에서의 요소 제거 및 추가 작업을 효율적으로 처리할 수 있게 되었습니다.

- **Map과 LinkedList의 결합**: Map을 사용하여 유저별로 대기열을 관리하면서, LinkedList를 통해 대기열의 성능을 최적화하였습니다.
- **성능 개선**: 전체적으로 Mutex 적용 범위를 줄이고, Map과 LinkedList를 활용하여 성능을 개선한 결과, 동시성 문제 해결과 성능 최적화를 모두 달성할 수 있었습니다.


# 구현내용
1. MutexInterceptor: : 요청이 들어올 때마다 하나의 요청만 처리하도록 잠금(Mutex)을 적용하여, 중복된 요청이 순차적으로 처리되게 하였습니다. 이로 인해 한 요청이 완료되기 전에는 다른 요청이 처리되지 않도록 보장하였습니다. (이후 큐로 개선)

2. 동시성 통합 테스트 : 동시성 문제 해결의 정확성을 검증하기 위해 통합 테스트를 작성하였습니다. 여러 개의 충전 및 사용 요청을 동시에 보내는 시나리오에서 요청들이 순차적으로 처리되고, 그 결과가 일관되게 반영되는지를 테스트했습니다.
```tsx
const promise1 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 100 }).expect(200);
const promise2 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 200 }).expect(200);
const promise3 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 300 }).expect(200);
```
