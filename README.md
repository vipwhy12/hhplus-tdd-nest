### 동시성 문제 해결 사례

#### 1. **문제 상황**
동시성 문제는 여러 요청이 동시에 같은 자원을 접근할 때 발생할 수 있는 문제입니다. `hhplus-tdd-nest` 프로젝트에서는 **포인트 충전 및 사용**과 같은 작업이 동시에 요청될 때 데이터 불일치 또는 경합 조건(race condition)이 발생할 수 있었습니다. 이러한 상황에서는 서로 다른 트랜잭션이 같은 데이터를 동시에 읽고 쓰려 할 때 문제가 발생할 수 있습니다.

#### 2. ** 이전의 구현 과정 **
프로젝트에서는 `MutexInterceptor`를 도입하여 **동시성 제어**를 구현했습니다. 이 Interceptor는 각 사용자의 요청을 순차적으로 처리하도록 설계되었습니다. 이를 통해 같은 사용자가 동시에 포인트 충전이나 사용을 요청할 때 발생할 수 있는 충돌을 방지합니다.

- - **[MutexInterceptor](https://github.com/vipwhy12/hhplus-tdd-nest/pull/10)**: : 요청이 들어올 때마다 하나의 요청만 처리하도록 잠금(Mutex)을 적용하여, 중복된 요청이 순차적으로 처리되게 하였습니다. 이로 인해 한 요청이 완료되기 전에는 다른 요청이 처리되지 않도록 보장하였습니다. 

### 3. ** 개선구현 과정 **
서비스 레이어에 동시성 제어 적용: 개선된 방식에서는 동시성 제어 로직을 인터셉터에서 서비스 레이어로 이동하였으며, 유저 ID별로 잠금을 구현하였습니다. 즉, 각 유저마다 독립적인 락을 사용할 수 있게 설계하여, 동시 요청이 들어올 때도 유저별로 충돌이 발생하지 않도록 했습니다.

Map을 통한 락 관리: Map<UserId, LinkedList> 형태로 각 유저에 대한 락을 관리하였으며, UserId를 키로 사용해 유저별로 요청을 순차적으로 처리하도록 했습니다.

처음에는 요청을 배열로 관리하려 했으나, 배열의 shift 연산은 O(n) 시간 복잡도가 발생할 수 있는 단점이 있었습니다. 이를 해결하기 위해 LinkedList로 변경하였으며, O(1) 시간 복잡도로 요소를 제거할 수 있게 설계했습니다. 이를 통해 각 유저에 대한 요청이 빠르고 효율적으로 처리될 수 있도록 최적화했습니다.

#### 3. **구현 과정**
- **요청 큐 처리**: 포인트 충전 및 사용 기능에서, 각 요청이 동시에 들어오더라도 특정 사용자에 대해 먼저 들어온 요청이 처리된 후에 다음 요청이 처리되도록 하였습니다. 즉, **동시적인 요청을 순차적으로 실행**할 수 있게 설계되었습니다.
  
- **테스트 코드 작성**: 동시성 문제 해결의 정확성을 검증하기 위해 통합 테스트를 작성하였습니다. 여러 개의 충전 및 사용 요청을 동시에 보내는 시나리오에서 요청들이 순차적으로 처리되고, 그 결과가 일관되게 반영되는지를 테스트했습니다.

  예를 들어, 세 개의 충전 요청이 동시에 들어올 때:
  ```typescript
  const promise1 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 100 }).expect(200);
  const promise2 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 200 }).expect(200);
  const promise3 = request(app.getHttpServer()).patch(`/point/${userId}/charge`).send({ amount: 300 }).expect(200);
  ```
  각 요청이 순차적으로 처리되어 포인트가 적절히 반영되는지 확인하였습니다.


#### 4. **인터셉터를 통한 동시성 제어에 대한 고찰**
NestJS의 인터셉터 메커니즘을 활용하여 비즈니스 로직과 분리된 형태로 동시성 제어를 구현할 수 있습니다. 하지만 해당 과제를 진행하면서, 동시성 제어에 대한 테스트 코드 위치가 모호해 지면서, 해당 부분에 대한 고민이 생겼습니다.

#### 5. **결과**
이 해결 방안을 통해 동시성 문제로 인한 데이터 불일치 현상을 방지할 수 있었습니다. MutexInterceptor가 동시 요청을 안전하게 처리하며, 각 요청이 올바르게 순차적으로 실행되었음을 통합 테스트를 통해 검증하였습니다.

